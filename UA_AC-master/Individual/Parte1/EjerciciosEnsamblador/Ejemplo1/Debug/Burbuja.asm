; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28316.0 

	TITLE	C:\Users\Anubis\Desktop\UA\UAADCProjects\Individual\Parte1\EjerciciosEnsamblador\Ejemplo1\Burbuja.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__08D173E2_stdlib@h DB 01H
__D9A2886B_corecrt_stdio_config@h DB 01H
__FA4B997B_corecrt_wstdio@h DB 01H
__4C6EA709_stdio@h DB 01H
__E7B46051_Burbuja@cpp DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_s_l
PUBLIC	_printf_s
PUBLIC	?bubbleSort@@YAXQAHH@Z				; bubbleSort
PUBLIC	?swapNumber@@YAXPAH0@Z				; swapNumber
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BP@OFMNDPMB@Valor?5del?5array?5desordenado?3?5?6@ ; `string'
PUBLIC	??_C@_04CAGLFDOE@?$CFd?0?5@			; `string'
PUBLIC	??_C@_05CCKENJDG@?$CFd?5?6?6@			; `string'
PUBLIC	??_C@_0BM@BEPKFEPK@Valor?5del?5array?5ordenado?3?5?6@ ; `string'
PUBLIC	??_C@_04EGBKGGKI@?$CFd?5?6@			; `string'
EXTRN	__imp___aligned_malloc:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf_s:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_04EGBKGGKI@?$CFd?5?6@
CONST	SEGMENT
??_C@_04EGBKGGKI@?$CFd?5?6@ DB '%d ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BEPKFEPK@Valor?5del?5array?5ordenado?3?5?6@
CONST	SEGMENT
??_C@_0BM@BEPKFEPK@Valor?5del?5array?5ordenado?3?5?6@ DB 'Valor del array'
	DB	' ordenado: ', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCKENJDG@?$CFd?5?6?6@
CONST	SEGMENT
??_C@_05CCKENJDG@?$CFd?5?6?6@ DB '%d ', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CAGLFDOE@?$CFd?0?5@
CONST	SEGMENT
??_C@_04CAGLFDOE@?$CFd?0?5@ DB '%d, ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFMNDPMB@Valor?5del?5array?5desordenado?3?5?6@
CONST	SEGMENT
??_C@_0BP@OFMNDPMB@Valor?5del?5array?5desordenado?3?5?6@ DB 'Valor del ar'
	DB	'ray desordenado: ', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Anubis\Desktop\UA\UAADCProjects\Individual\Parte1\EjerciciosEnsamblador\Ejemplo1\Burbuja.cpp
;	COMDAT _main
_TEXT	SEGMENT
_i$1 = -56						; size = 4
_i$2 = -44						; size = 4
_arr$ = -32						; size = 4
_byteCount$ = -20					; size = 4
_arrSize$ = -8						; size = 4
_main	PROC						; COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E7B46051_Burbuja@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 13   :     const int arrSize = 20;

	mov	DWORD PTR _arrSize$[ebp], 20		; 00000014H

; 14   :     
; 15   :     int byteCount = sizeof(int) * arrSize;

	mov	DWORD PTR _byteCount$[ebp], 80		; 00000050H

; 16   : 
; 17   :     int* arr = (int*)_aligned_malloc(byteCount, 16);

	mov	esi, esp
	push	16					; 00000010H
	mov	eax, DWORD PTR _byteCount$[ebp]
	push	eax
	call	DWORD PTR __imp___aligned_malloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _arr$[ebp], eax

; 18   :     if (arr == NULL)

	cmp	DWORD PTR _arr$[ebp], 0
	jne	SHORT $LN8@main

; 19   :         return 1;

	mov	eax, 1
	jmp	$LN14@main
$LN8@main:

; 20   : 
; 21   :     srand(27015);

	mov	esi, esp
	push	27015					; 00006987H
	call	DWORD PTR __imp__srand
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 22   : 
; 23   :     printf_s("Valor del array desordenado: \n");

	push	OFFSET ??_C@_0BP@OFMNDPMB@Valor?5del?5array?5desordenado?3?5?6@
	call	_printf_s
	add	esp, 4

; 24   :     for (size_t i = 0; i < arrSize; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@main:
	cmp	DWORD PTR _i$2[ebp], 20			; 00000014H
	jae	SHORT $LN3@main

; 25   :     {
; 26   :         arr[i] = rand();

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	edx, DWORD PTR _arr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 27   : 
; 28   :         if (i + 1 != arrSize)

	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	cmp	eax, 20					; 00000014H
	je	SHORT $LN9@main

; 29   :             printf_s("%d, ", arr[i]);

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _arr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_04CAGLFDOE@?$CFd?0?5@
	call	_printf_s
	add	esp, 8
	jmp	SHORT $LN10@main
$LN9@main:

; 30   :         else
; 31   :             printf_s("%d \n\n", arr[i]);

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _arr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_05CCKENJDG@?$CFd?5?6?6@
	call	_printf_s
	add	esp, 8
$LN10@main:

; 32   :     }

	jmp	SHORT $LN2@main
$LN3@main:

; 33   : 
; 34   :     bubbleSort(arr, arrSize);

	push	20					; 00000014H
	mov	eax, DWORD PTR _arr$[ebp]
	push	eax
	call	?bubbleSort@@YAXQAHH@Z			; bubbleSort
	add	esp, 8

; 35   : 
; 36   :     printf_s("Valor del array ordenado: \n");

	push	OFFSET ??_C@_0BM@BEPKFEPK@Valor?5del?5array?5ordenado?3?5?6@
	call	_printf_s
	add	esp, 4

; 37   :     for (size_t i = 0; i < arrSize; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@main
$LN5@main:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN7@main:
	cmp	DWORD PTR _i$1[ebp], 20			; 00000014H
	jae	SHORT $LN6@main

; 38   :     {
; 39   :         if (i+1 != arrSize)

	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	cmp	eax, 20					; 00000014H
	je	SHORT $LN11@main

; 40   :             printf_s("%d, ", arr[i]);

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _arr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_04CAGLFDOE@?$CFd?0?5@
	call	_printf_s
	add	esp, 8
	jmp	SHORT $LN12@main
$LN11@main:

; 41   :         else
; 42   :             printf_s("%d \n", arr[i]);

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _arr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_04EGBKGGKI@?$CFd?5?6@
	call	_printf_s
	add	esp, 8
$LN12@main:

; 43   :     }

	jmp	SHORT $LN5@main
$LN6@main:

; 44   : 
; 45   : }

	jmp	SHORT $LN15@main
	jmp	SHORT $LN14@main
$LN15@main:
	xor	eax, eax
$LN14@main:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Anubis\Desktop\UA\UAADCProjects\Individual\Parte1\EjerciciosEnsamblador\Ejemplo1\Burbuja.cpp
;	COMDAT ?swapNumber@@YAXPAH0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?swapNumber@@YAXPAH0@Z PROC				; swapNumber, COMDAT

; 86   : void swapNumber(int* a, int* b) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 87   :     __asm
; 88   :     {
; 89   :         // Haciendo que las variables de nustro codigo en C sea usable en nuestro bloque __asm.
; 90   :         mov esi, a;        // guardamos las referencias de las variables en un registro.

	mov	esi, DWORD PTR _a$[ebp]

; 91   :         mov edi, b;        // guardamos las referencias de las variables en un registro.

	mov	edi, DWORD PTR _b$[ebp]

; 92   : 
; 93   :         // Empieza la manipulacion
; 94   :         mov eax, [esi];    // guardamos los valores en memoria de las referencias en un registro.

	mov	eax, DWORD PTR [esi]

; 95   :         mov ebx, [edi];    // guardamos los valores en memoria de las referencias en un registro.

	mov	ebx, DWORD PTR [edi]

; 96   : 
; 97   :         xchg eax, ebx;     // damos la vuelta a los valores que tenemos guardados en los registros.

	xchg	eax, ebx

; 98   : 
; 99   :         mov [esi], eax;    // guardamos los valores de los registros de vuelta a la memoria.

	mov	DWORD PTR [esi], eax

; 100  :         mov [edi], ebx;    // guardamos los valores de los registros de vuelta a la memoria.

	mov	DWORD PTR [edi], ebx

; 101  : 
; 102  :     }
; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?swapNumber@@YAXPAH0@Z ENDP				; swapNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Anubis\Desktop\UA\UAADCProjects\Individual\Parte1\EjerciciosEnsamblador\Ejemplo1\Burbuja.cpp
;	COMDAT ?bubbleSort@@YAXQAHH@Z
_TEXT	SEGMENT
_a$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_arr$ = 8						; size = 4
_size$ = 12						; size = 4
?bubbleSort@@YAXQAHH@Z PROC				; bubbleSort, COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 49   :     int a = size - 2;           // tamaño - 2 porque estámos comporbando cada 2 grupos a la vez, por lo tanto, el ultimo par no se comprueba

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 2
	mov	DWORD PTR _a$[ebp], eax

; 50   :                                 //    ya que si se hace, se saldria fuera del rango del vector, y comprobaria la ult. pos. con algo
; 51   :                                 //    que no hace parte del vector.
; 52   : 
; 53   :     __asm {
; 54   :             mov esi, arr        // Asingamos la dir del inicio del array a esi.

	mov	esi, DWORD PTR _arr$[ebp]

; 55   :             mov edi, a;         // Asignamos el tamaño del array a edi.

	mov	edi, DWORD PTR _a$[ebp]

; 56   :             mov eax, edi;       // eax = contador externo.

	mov	eax, edi
$externo$3:

; 57   :         
; 58   :         externo:                // Tag del bucle externo.
; 59   :             mov ebx, edi;       // ebx = contador interno.

	mov	ebx, edi
$interno$4:

; 60   : 
; 61   :         interno:                // Tag del bucle interno.
; 62   :             mov ecx, [esi];     // ecx = valor de la pos. actual del vector.

	mov	ecx, DWORD PTR [esi]

; 63   :             mov edx, [esi + 4]; // edx = Valor posición siguiente.

	mov	edx, DWORD PTR [esi+4]

; 64   :             cmp ecx, edx;       // Comparamos el valor actual con el siguiente, el resultado e 

	cmp	ecx, edx

; 65   :             jl guardar;         // Si el valor actual ECX es menor que la siguiente [ESI + 4], entonces nos saltamos el paso de intercambiarlos.

	jl	SHORT $guardar$5

; 66   : 
; 67   :             xchg ecx, edx;      // Intercambiamos.

	xchg	ecx, edx
$guardar$5:

; 68   : 
; 69   :         guardar:                // Tag  de las operaciones comunes por iteracion.
; 70   :             mov [esi], ecx;     // Guardamos el valor actual.

	mov	DWORD PTR [esi], ecx

; 71   :             mov [esi + 4], edx; // Guardamos el valor siguiente.

	mov	DWORD PTR [esi+4], edx

; 72   : 
; 73   :             add esi, 4;         // Incrementamos el registro en 4 para pasar a la siguiente posición del vector.

	add	esi, 4

; 74   : 
; 75   :             dec ebx;            // Decretemntamos 1 en el contador interno.

	dec	ebx

; 76   :             jnz interno;        // Si no es 0, repetimos el bucle interno.

	jne	SHORT $interno$4

; 77   : 
; 78   :             mov esi, arr        // Re-asingamos la dir del inicio del array a esi

	mov	esi, DWORD PTR _arr$[ebp]

; 79   :             dec eax;            // Decrementamos 1 en el contador externo.

	dec	eax

; 80   :             jnz externo;        // Si no es 0, repetimos el bucle externo.

	jne	SHORT $externo$3

; 81   :     
; 82   :     }
; 83   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?bubbleSort@@YAXQAHH@Z ENDP				; bubbleSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf_s
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf_s PROC						; COMDAT

; 991  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4C6EA709_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 992  :             int _Result;
; 993  :             va_list _ArgList;
; 994  :             __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 995  :             _Result = _vfprintf_s_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__vfprintf_s_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 996  :             __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 997  :             return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 998  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_s_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_s_l PROC					; COMDAT

; 671  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4C6EA709_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 672  :         return __stdio_common_vfprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf_s
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 673  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __D9A2886B_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
